picotron cartridge // www.picotron.net
version 2

:: func.lua
--[[pod_format="raw",created="2025-03-27 14:30:08",modified="2025-03-28 11:55:50",revision=161]]
function normalizeSignal(points)
  local complex_signal = {}
  local min_x, max_x = 480, 0
  local min_y, max_y = 270, 0
  
  -- Find bounds
--  for _, p in ipairs(points) do
--    min_x = min(min_x, p.x)
--    max_x = max(max_x, p.x)
--    min_y = min(min_y, p.y)
--    max_y = max(max_y, p.y)
--  end
  
  -- Normalize to [-1, 1] range
  for _, p in ipairs(points) do
    local x_norm = ((p.x - min_x)/(max_x - min_x))*2 - 1
    local y_norm = ((p.y - min_y)/(max_y - min_y))*2 - 1
    add(complex_signal, {real=-x_norm, imag=y_norm})  -- Flip Y for screen coords
  end
  
  return resampleToPowerOf2(complex_signal)
end

function resampleToPowerOf2(signal, closed_curve)
    local current_length = #signal
    if current_length == 0 then return {} end
    
    local target_length = 1
    while target_length < current_length do
        target_length = target_length * 2
    end
    
    local resampled = {}
    for i = 1, target_length do
        local pos = (i-1)/(target_length-1) * current_length + 1
        local idx = flr(pos)
        local frac = pos - idx
        
        local next_idx = idx + 1
        if closed_curve then
            idx = (idx - 1) % current_length + 1
            next_idx = (next_idx - 1) % current_length + 1
        end
        
        if not closed_curve and idx >= current_length then
            add(resampled, signal[current_length])
        else
            local s1 = signal[idx]
            local s2 = signal[next_idx] or signal[1]
            add(resampled, {
                real = s1.real + frac*(s2.real - s1.real),
                imag = s1.imag + frac*(s2.imag - s1.imag)
            })
        end
    end
    
    return resampled
end
:: main.lua
--[[pod_format="raw",created="2025-03-27 12:29:05",modified="2025-03-28 11:55:50",revision=358]]
include"func.lua"

function _init()
	sine_waves = {}
	shape_points = {}
	signal = {}
	analyse = 0
	-- Separate x and y sine wave collections
	x_sine_waves = {{ampl=-0.29583333333333,freq=1,phas=0.095974344563093},{ampl=-0.23472222222222,freq=2,phas=0.071240409757214},{ampl=-0.15277777777778,freq=3,phas=0.042532122063708},{ampl=-0.05,freq=4,phas=0.012466376809635},{ampl=0.083333333333333,freq=5,phas=-0.018957813934491},{ampl=0.225,freq=6,phas=-0.047231111622636},{ampl=0.375,freq=7,phas=-0.073323733451551},{ampl=0.52222222222222,freq=8,phas=-0.09823574802426},{ampl=0.62361111111111,freq=9,phas=-0.11430894014088},{ampl=0.67916666666667,freq=10,phas=-0.12387017732671},{ampl=0.7125,freq=11,phas=-0.13117530505396},{ampl=0.73194444444444,freq=12,phas=-0.13540849241149},{ampl=0.7375,freq=13,phas=-0.13661309501493},{ampl=0.7375,freq=14,phas=-0.13722545030037},{ampl=0.7375,freq=15,phas=-0.13753315110539},{ampl=0.7375,freq=16,phas=-0.13753315110539}}
	y_sine_waves = {{ampl=0.51851851851852,freq=1,phas=0.099653726111089},{ampl=0.52296296296296,freq=2,phas=0.096981410579559},{ampl=0.54222222222222,freq=3,phas=0.087193018862306},{ampl=0.59111111111111,freq=4,phas=0.06330033564125},{ampl=0.64296296296296,freq=5,phas=0.034712779488148},{ampl=0.6962962962963,freq=6,phas=0.0057119418615375},{ampl=0.73185185185185,freq=7,phas=-0.027979378108321},{ampl=0.75703703703704,freq=8,phas=-0.051237888504523},{ampl=0.76148148148148,freq=9,phas=-0.061531977359595},{ampl=0.76,freq=10,phas=-0.068543616482111},{ampl=0.75555555555556,freq=11,phas=-0.074026410374512},{ampl=0.75111111111111,freq=12,phas=-0.077330826347116},{ampl=0.74666666666667,freq=13,phas=-0.079648406293954},{ampl=0.74222222222222,freq=14,phas=-0.080049054728783},{ampl=0.74074074074074,freq=15,phas=-0.080183424239829},{ampl=0.74074074074074,freq=16,phas=-0.080183424239829}}
end

function _update()
    mx, my, md = mouse()
    if md != 0 then
        if #shape_points != 0 then
            if shape_points[#shape_points].x == mx and shape_points[#shape_points].y == my then
                return
            end
        end
        add(shape_points, {x=mx, y=my})
    end
    
    if btnp(4) then
        analyse += 1
        signal = normalizeSignal(shape_points)
        
        x_sine_waves = {}
        y_sine_waves = {}
        
        for i=1, #signal do
            -- X-coordinate sine waves
            x_signal_ampl = sqrt(signal[i].real * signal[i].real + signal[i].imag * signal[i].imag)
            x_signal_phas = atan2(signal[i].imag, signal[i].real)
            
            add(x_sine_waves, {
                ampl = signal[i].real,  -- Use real part directly
                phas = x_signal_phas, 
                freq = i
            })
            
            -- Y-coordinate sine waves
            y_signal_ampl = sqrt(signal[i].real * signal[i].real + signal[i].imag * signal[i].imag)
            y_signal_phas = atan2(signal[i].imag, signal[i].real)
            
            add(y_sine_waves, {
                ampl = signal[i].imag,  -- Use imaginary part directly
                phas = y_signal_phas, 
                freq = i
            })
        end    
    end
end

function _draw()
	cls()
	for i = 1, #shape_points do
		if i != 1 then
			line(shape_points[i].x, shape_points[i].y, shape_points[i-1].x, shape_points[i-1].y, 7)
		end
	end
	
	for i = 1, #signal do
		if i != 1 then
			local x1 = (signal[i-1].real + 1) * 240  -- 480/2 = 240
			local y1 = (-signal[i-1].imag + 1) * 135  -- 270/2 = 135, flip Y
			local x2 = (signal[i].real + 1) * 240
			local y2 = (-signal[i].imag + 1) * 135
			
			line(x1, y1, x2, y2, 8)
		end
	end
	
	pi = 3.14159265358979
	
	if btn(5) then
		string = "{"
		for j = 1, #y_sine_waves do
			x_ampl, x_freq, x_phas = y_sine_waves[j].ampl, y_sine_waves[j].freq, y_sine_waves[j].phas
			string = 	string.."{ampl="..x_ampl..",freq="..x_freq..",phas="..x_phas.."},"
		end
		string = string.."}"
		set_clipboard(string)
	end
	
	for i = 0, 480-1 do
        x = 0
        y = 0
        
        -- Calculate x-coordinate
        for j = 1, #x_sine_waves do    
            x_ampl, x_freq, x_phas = x_sine_waves[j].ampl, x_sine_waves[j].freq, x_sine_waves[j].phas
            x += x_ampl * sin(2*pi*x_freq*i + x_phas)
        end
        
        -- Calculate y-coordinate
        for j = 1, #y_sine_waves do    
            y_ampl, y_freq, y_phas = y_sine_waves[j].ampl, y_sine_waves[j].freq, y_sine_waves[j].phas
            y += y_ampl * sin(2*pi*y_freq*i + y_phas)
        end
        
        -- Plot the reconstructed point
        pset(x*100+240, y*100+135, 7)
        
    end
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAzLTI3IDEyOjI4OjQ5Iixtb2RpZmllZD0iMjAyNS0w
My0yOCAxMTo1NTo1MCIscnVudGltZT0xMix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzQiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImZ1bmMubHVhIzE4Iix3b3Jrc3BhY2Vf
aW5kZXg9MX19XV0=
:: [eoc]
